Ce o sa fac la prezentare:

1. load, load_default
2. to_mono
3. into_rodio_source
4. autocorr
5. resample
5. lpc
6. mu_quantize
7. stft

de rezolvat, chirp cu autocorr
mu_quantize de rezolvat

pentru prezentare
    - load_default
    - to_mono
    - resample
    - into_rodio_source

    - tone
    - mu_quantize
    - autocorr
    - lpc

    - load
    - stft
    
    - conv muzicale

slide 1: prima pagina
    - titlu
    - eu
    - rusu
slide 2: curprins
    - prezentare problema
    - justificarea problemei abordate
    - abordarea
    - librarii folosite
    - doua probleme
    - rezultate
    - concluzii
    - in viitor
slide 3: prezentarea problemei (problema abordata in teza)
    o biblioteca de procesare si analiza a semnalelor audio in Rust
    - o aplicabilitate larga
    - extragerea informatiilor din semnalele audio precum componentele de frecventa
    - scoaterea zgomotului, prin filtrarea semnalelor pentru o calitate superioara
    - comprimarea datelor pentru transmiterea eficienta a acestora
    - recunoastere vorbirii de catre masini
    - o componenta importanta a oricarui ecosistem de biblioteci

slide 4: motivatie
    - rust e un limbaj performant si axat pe siguranta
    - ecosistem de librarii incomplet
    - am vrut sa ajut la dezvoltarea limbajului
    - un gol pe care l am gasit in ecosistem a fost partea de procesare si analiza a semnalelor audio

slide 5: 
    - ca punct de referinta mi-am ales biblioteca librosa din python, o biblioteca completa pentru procesarea si analiza semnalelor audio
    - am implementat functionalitati din modulul core
    - pentru unele functionalitati, am integrat in biblioteca, crate-uri deja existente in limbaj
    - pentru altele am fost nevoit sa le implementez de la zero
slide 6: Biblioteci folosite
    - symphonia pentru decodare
    - rodio pentru redare
    - rubato pentru reesantionare
    - realfft pentru transformata Fourier
    - num-traits ofera trait-uri pentru a ramane generic
    - integrarea destul de complicata 
slide 7: Probleme cu care m-am confruntat
    - un design goal a fost ca biblioteca sa ofera un api usor de utilizat
    - acest lucru poate fi dificil din cauza faptul ca limbajul e axat pe siguranta, iar compilatorul e destul de dur
    - faptul ca compilatorul te obliga sa scrii cod corect, elimina multe variante de implementare care initial pareau a fi corecte
    - si acest lucru poate face dezvoltarea destul de complicata
slide 8: Fara parametrii impliciti
    - nu exista parametrii impliciti in Rust
    - mai multe variante de implementare
    - cu design pattern-ul Builder
    - fragmentarea functiilor in mai multe variante, de multe ori una default si una cu toti parametrii
slide 9: Generalitatea esantioanelor
    - biblioteca sa poata fi utilizata cu orice tip de esantioan
    - nu exista paradigma de programare orientata pe obiecte ca in alte limbaje, de exemplu nu exista mostenirea
    - trait-uri 
    - regula orfanului
slide 10: Rezultate
    - functii de incarcare si redare a semnalelor audio
    - functii de procesare in domeniul timpului
    - functii de generare a semnalelor sinusoidale
    - functii de conversie intre unitati de masura din domeniul frecventei
    - functii de reprezentare spectrala
slide 11: concluzii
    - viteza compilarii e mai scazuta
    - librosa implementeaza un sistem de chaching, dar chiar si asa
multe functii ofera rezultate mai bune si de doua ori
slide 12: in viitor
    - testare riguroasa si exhaustiva
    - documentatie
    - o modalitate de a afisa grafic spectrul frecventelor
slide 13: referinte


slide 5:
    un mare challenge a fost, integrarea mai multor librarii sub un api usor de utilizat
    regula orfanului
    doua probleme pe care le am intampinat
    sa raman generic peste mai multe tipuri de esantioane. Daca in alte limbaje de programare este folosita
    o paradigma de programare orientata pe obiecte, in Rust lipseste
    de exemplu lipseste mostenirea
    pentru a ramane generic, se folosesc trait-uri
    regula orfanului
    o strucutura poate implementa un trait, doar daca ori structura ori trait-ul este definit in crate-ul curent
    acest lucru a facut imposibil
slide 6:
    - functii de generare de semnale
    - functii de conversii intre diferite tipuri de frecvente
    - functii de procesare
    - functii de manipulare
    - reprezentare spectrala prin Transformata Fourier pe Termen Scurt
slide 7:
    - rezultate

sa vedem care-i treaba 

slide 8:
    - din cauza faptului ca viteza compilarii e destul de mare, in productie, unde se modifica constant ca in productia muzicala cred ca ar fi de preferat inca python
    - dar in situatii in care se folosesc, de exemplu de reesantionare sau din care vreau sa extrag frecventele, ar fi o varianta la standardul din limbajul python
    cu timp chiar mai buni de rulare
    - ce planuiesc in continuare
    - testat riguros, toate functiile au fost testate manual, rezultate fiind raportate la implementarea de referinta din librosa
    - documentat
    -
slide 9: In viitor
    - toate functiile au fost testate manual, rezultatele fiind raportate la implementerea de referinta din librosa
dar pentru a putea fi publicata, trebuie sa dea o siguranta mai mare, testare automata si riguroasa
    - codul trebuie documentat
    - si gasesc necesara si implemtarea unei metode de a putea vizualiza frecventele extrase, ori pe baza unei librarii deja existente
ori cu o implementare de la zero